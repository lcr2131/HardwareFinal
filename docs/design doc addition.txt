This can go in either Test Harness Structure, or Verification Strategy:

	The testbench has three processors: one is the device under test, and the other two are verification models. One verification model, the golden result, is extremely simple. It simulates the result of one MIPS instruction at a time (using an array for memory and another for registers), without performing out-of-order execution or pipelining. Because it is made of only a few lines of code and has no advanced features, it is very trustworthy. However, it is too simple to help the design team if there are any bugs.
	The second verification model is detailed and mimics our design. There are subprograms for each pipeline stage, which are executed in sequence to simulate one clock cycle. It is much more complicated than the golden result processor, so the testbench has a Check Model feature that runs a program on the very simple processor and on the pipelined processor and compares the results. This allows us to find any bugs in the verification model and gain confidence in its correctness. Once the detailed pipeline processor seems to be working correctly, it can be used to verify the DUT.
	To verify the design, the pipelined model processor in the bench simulates one cycle while the DUT runs for one cycle. The contents of data memory are compared as well as any other signals of interest. This is repeated for any number of cycles.
	The inputs to the DUT and bench processor are instructions that come from a random program generator. The generator can produce programs that use only a subset of registers, instructions, and immediate operands, based on the settings in the config file. It can generate programs that are free of data hazards. By turning off more complicated instructions like branching and by removing hazards, we can verify the critical parts of the processor first, then try out more challanging inputs.

